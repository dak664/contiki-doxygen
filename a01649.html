<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Contiki 2.5: USB Mass Storage Task</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USB Mass Storage Task<br/>
<small>
[<a class="el" href="a01677.html">RZRAVEN USB Stick (Jackdaw)</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84a55b954a9d270664ddcdf4c3780ff3"></a><!-- doxytag: member="usbstorage::ENTRY_SIZE" ref="ga84a55b954a9d270664ddcdf4c3780ff3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga84a55b954a9d270664ddcdf4c3780ff3">ENTRY_SIZE</a>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FAT specification. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga623d8b583417db8483269264d5af1992"></a><!-- doxytag: member="usbstorage::LUN_0_EN" ref="ga623d8b583417db8483269264d5af1992" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga623d8b583417db8483269264d5af1992">LUN_0_EN</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computed the maximum of static lun (don't add the lun of Mass Storage in mode USB Host). <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Define control status. </p>
<br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga77ad6433358d065ff854213e9373d7f5">avrf_mem_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function initializes the hw/sw ressources required to drive the AVR Flash.  <a href="#ga77ad6433358d065ff854213e9373d7f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga6e798ae4398574d515c802a550e506ef">avrf_test_unit_ready</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function tests the state of the AVR Flash.  <a href="#ga6e798ae4398574d515c802a550e506ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaf09c88763a4deac0ac2c4aa9b49c12ba">avrf_read_capacity</a> (U32 *u32_nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function gives the address of the last valid sector.  <a href="#gaf09c88763a4deac0ac2c4aa9b49c12ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaf950b7a4776b0e3215c35648fab8970d">avrf_wr_protect</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the write protected status of the memory.  <a href="#gaf950b7a4776b0e3215c35648fab8970d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaaef951f3f6464080d642206ce3373f9e">avrf_removal</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function tells if the memory has been removed or not.  <a href="#gaaef951f3f6464080d642206ce3373f9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga33e2bcc937348de850e812a7237884fd">avrf_read_10</a> (U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a read operation of n sectors from a given address on.  <a href="#ga33e2bcc937348de850e812a7237884fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gae930b7ef893039dc7d223c465503f9eb">avrf_write_10</a> (U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction initialise the memory for a write operation.  <a href="#gae930b7ef893039dc7d223c465503f9eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gae3e4d52c834618e9dd4d53693e51e37c">avrf_read_open</a> (Uint32 pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function opens a DF memory in read mode at a given sector address.  <a href="#gae3e4d52c834618e9dd4d53693e51e37c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga47f968c9851adffa93ec0bb93fe199ec">avrf_read_close</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function unselects the current DF memory.  <a href="#ga47f968c9851adffa93ec0bb93fe199ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga0f093c1d7161da224ecb07383d61f19e">avrf_read_sector</a> (Uint16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is optimized and writes nb-sector * 512 Bytes from DataFlash memory to USB controller.  <a href="#ga0f093c1d7161da224ecb07383d61f19e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaa02eeb6bbe862a09f6cdc9d1f1e7e626">avrf_write_open</a> (Uint32 pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function opens a DF memory in write mode at a given sector address.  <a href="#gaa02eeb6bbe862a09f6cdc9d1f1e7e626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga194c6ce2ff9866b05187d8390d0f941a">avrf_write_close</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function fills the end of the logical sector (512B) and launch page programming.  <a href="#ga194c6ce2ff9866b05187d8390d0f941a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bit&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gafde2632a16c95692a907eada19dfaaef">avrf_write_sector</a> (Uint16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is optimized and writes nb-sector * 512 Bytes from USB controller to DataFlash memory.  <a href="#gafde2632a16c95692a907eada19dfaaef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gae299afa5d49375940e57f9642ef709a8">avrf_usb_read</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction transfer the memory data (programed in scsi_read_10) directly to the usb interface.  <a href="#gae299afa5d49375940e57f9642ef709a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga41a77d679390a374002e43a7e5b95f21">avrf_usb_write</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction transfer the usb data (programed in scsi_write_10) directly to the memory data.  <a href="#ga41a77d679390a374002e43a7e5b95f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga77a287c5aa53679242c3827b11a71252">get_nb_lun</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return the number of logical unit.  <a href="#ga77a287c5aa53679242c3827b11a71252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga76c903dae1ac07d6ef569b5c44e1644b">get_cur_lun</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return the current logical unit.  <a href="#ga76c903dae1ac07d6ef569b5c44e1644b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga51555be425eeacfd88e603b9cba97049">mem_test_unit_ready</a> (U8 lun)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction test the state of memory, and start the initialisation of the memory.  <a href="#ga51555be425eeacfd88e603b9cba97049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gace55e62f4e2b09da845c260ee52c69ab">mem_read_capacity</a> (U8 lun, U32 _MEM_TYPE_SLOW_ *u32_nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return the capacity of the memory.  <a href="#gace55e62f4e2b09da845c260ee52c69ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaf4b64acad5f46d01e082d7a7301078df">mem_wr_protect</a> (U8 lun)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return is the write protected mode.  <a href="#gaf4b64acad5f46d01e082d7a7301078df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gab56313733936ea087a9eb2285a913554">mem_removal</a> (U8 lun)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction inform about the memory type.  <a href="#gab56313733936ea087a9eb2285a913554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga1bc5f6636e0c33423bd45149c8b52aa5">memory_2_usb</a> (U8 lun, U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction returns a pointer to the LUN name.  <a href="#ga1bc5f6636e0c33423bd45149c8b52aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga009fb70f78b2582820da7d32ecbcb44f">usb_2_memory</a> (U8 lun, U32 addr, U16 nb_sector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction trabsfer a data from usb to memory.  <a href="#ga009fb70f78b2582820da7d32ecbcb44f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaffa6469099cc7713cfbfd73f6c5dd022">scsi_decode_command</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCSI decoder function.  <a href="#gaffa6469099cc7713cfbfd73f6c5dd022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gae6a977561cdadab81fcb0a1ddf54e599">sbc_request_sense</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function manages the SCSI REQUEST SENSE command (0x03).  <a href="#gae6a977561cdadab81fcb0a1ddf54e599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga5ab123cdf7ce0be905307fad2e714557">sbc_inquiry</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function manages the SCSI INQUIRY command (0x12).  <a href="#ga5ab123cdf7ce0be905307fad2e714557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gace91bd174f189c655249a901e4ce138c">sbc_mode_sense</a> (Bool b_sense_10)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function manages the SCSI MODE SENSE command (0x1A for sense 6 and 0x5A for sense 10).  <a href="#gace91bd174f189c655249a901e4ce138c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga3afa976ae770c2ef5053d7b2c1b61dde">sbc_prevent_allow_medium_removal</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function manages the SCSI PREVENT ALLOW MEDIUM REMOVAL command (0x1E).  <a href="#ga3afa976ae770c2ef5053d7b2c1b61dde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a32a04cfe5f86c7200512a2dee798f8"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_good" ref="ga6a32a04cfe5f86c7200512a2dee798f8" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga6a32a04cfe5f86c7200512a2dee798f8">sbc_lun_status_is_good</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction send the UFI status GOOD. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03f2e185631cefb98ce3076deb698640"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_not_present" ref="ga03f2e185631cefb98ce3076deb698640" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga03f2e185631cefb98ce3076deb698640">sbc_lun_status_is_not_present</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction send the UFI status "lun not present". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga070e6444e67e90bc02263d8c7120f639"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_busy_or_change" ref="ga070e6444e67e90bc02263d8c7120f639" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga070e6444e67e90bc02263d8c7120f639">sbc_lun_status_is_busy_or_change</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction send the UFI status busy and change. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f9fe80f550dbf8d9c3c60516bb6dad6"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_fail" ref="ga8f9fe80f550dbf8d9c3c60516bb6dad6" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga8f9fe80f550dbf8d9c3c60516bb6dad6">sbc_lun_status_is_fail</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction send the UFI status FAIL. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4f9cd3f5771069c76997ba86944bffc"></a><!-- doxytag: member="usbstorage::sbc_lun_status_is_protected" ref="gaf4f9cd3f5771069c76997ba86944bffc" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaf4f9cd3f5771069c76997ba86944bffc">sbc_lun_status_is_protected</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction send the UFI status FAIL because write protection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga8ad8d2f18d5af0ed75b541ab3ca9a7ff">usb_mass_storage_cbw</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Command Block Wrapper (CBW) management.  <a href="#ga8ad8d2f18d5af0ed75b541ab3ca9a7ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gaed223d0bc3ba362c7f3cc8766ff614f0">usb_mass_storage_csw</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Command Status Wrapper (CSW) management.  <a href="#gaed223d0bc3ba362c7f3cc8766ff614f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#gabb2f5aeb58ca9e0dac6004b5abbff30b">PROCESS_THREAD</a> (storage_process, ev, data_proc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Mass Storage Class Process.  <a href="#gabb2f5aeb58ca9e0dac6004b5abbff30b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17e7aa663c771d6bddfea612365b55ee"></a><!-- doxytag: member="usbstorage::usb_configuration_nb" ref="ga17e7aa663c771d6bddfea612365b55ee" args="" -->
U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01649.html#ga17e7aa663c771d6bddfea612365b55ee">usb_configuration_nb</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Public : (U8) usb_configuration_nb Store the number of the USB configuration used by the USB device when its value is different from zero, it means the device mode is enumerated Used with USB_DEVICE_FEATURE == ENABLED only /. <br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga77ad6433358d065ff854213e9373d7f5"></a><!-- doxytag: member="avr_flash.c::avrf_mem_init" ref="ga77ad6433358d065ff854213e9373d7f5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avrf_mem_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes the hw/sw ressources required to drive the AVR Flash. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<p>/ </p>

</div>
</div>
<a class="anchor" id="ga33e2bcc937348de850e812a7237884fd"></a><!-- doxytag: member="avr_flash.c::avrf_read_10" ref="ga33e2bcc937348de850e812a7237884fd" args="(U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_read_10 </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function performs a read operation of n sectors from a given address on. </p>
<p>(sector = 512B)</p>
<p>DATA FLOW is: AVRF =&gt; USB</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Sector address to start the read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL </dd></dl>

</div>
</div>
<a class="anchor" id="gaf09c88763a4deac0ac2c4aa9b49c12ba"></a><!-- doxytag: member="avr_flash.c::avrf_read_capacity" ref="gaf09c88763a4deac0ac2c4aa9b49c12ba" args="(U32 *u32_nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_read_capacity </td>
          <td>(</td>
          <td class="paramtype">U32 *&nbsp;</td>
          <td class="paramname"> <em>u32_nb_sector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function gives the address of the last valid sector. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*u32_nb_sector</em>&nbsp;</td><td>number of sector (sector = 512B). OUT</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD / </dd></dl>

<p>Definition at line <a class="el" href="a00717_source.html#l00122">122</a> of file <a class="el" href="a00717_source.html">avr_flash.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga47f968c9851adffa93ec0bb93fe199ec"></a><!-- doxytag: member="avr_flash.c::avrf_read_close" ref="ga47f968c9851adffa93ec0bb93fe199ec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avrf_read_close </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function unselects the current DF memory. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<p>/ </p>

</div>
</div>
<a class="anchor" id="gae3e4d52c834618e9dd4d53693e51e37c"></a><!-- doxytag: member="avr_flash.c::avrf_read_open" ref="gae3e4d52c834618e9dd4d53693e51e37c" args="(Uint32 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_read_open </td>
          <td>(</td>
          <td class="paramtype">Uint32&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function opens a DF memory in read mode at a given sector address. </p>
<p>NOTE: Address may not be synchronized on the beginning of a page (depending on the DF page size).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Logical sector address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The open succeeded -&gt; OK / </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f093c1d7161da224ecb07383d61f19e"></a><!-- doxytag: member="avr_flash.c::avrf_read_sector" ref="ga0f093c1d7161da224ecb07383d61f19e" args="(Uint16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_read_sector </td>
          <td>(</td>
          <td class="paramtype">Uint16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is optimized and writes nb-sector * 512 Bytes from DataFlash memory to USB controller. </p>
<p>DATA FLOW is: DF =&gt; USB</p>
<p>NOTE:</p>
<ul>
<li>First call must be preceded by a call to the df_read_open() function,</li>
<li>The USB EPIN must have been previously selected,</li>
<li>USB ping-pong buffers are free,</li>
<li>As 512 is always a sub-multiple of page size, there is no need to check page end for each Bytes,</li>
<li>Interrupts are disabled during transfer to avoid <a class="el" href="a00086.html" title="A timer.">timer</a> interrupt,</li>
<li>nb_sector always &gt;= 1, cannot be zero.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>number of contiguous sectors to read [IN]</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The read succeeded -&gt; OK / </dd></dl>

</div>
</div>
<a class="anchor" id="gaaef951f3f6464080d642206ce3373f9e"></a><!-- doxytag: member="avr_flash.c::avrf_removal" ref="gaaef951f3f6464080d642206ce3373f9e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool avrf_removal </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function tells if the memory has been removed or not. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE -&gt; The memory isn't removed / </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e798ae4398574d515c802a550e506ef"></a><!-- doxytag: member="avr_flash.c::avrf_test_unit_ready" ref="ga6e798ae4398574d515c802a550e506ef" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_test_unit_ready </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function tests the state of the AVR Flash. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD Else -&gt; CTRL_NO_PRESENT / </dd></dl>

</div>
</div>
<a class="anchor" id="gae299afa5d49375940e57f9642ef709a8"></a><!-- doxytag: member="avr_flash.c::avrf_usb_read" ref="gae299afa5d49375940e57f9642ef709a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_usb_read </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction transfer the memory data (programed in scsi_read_10) directly to the usb interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD </dd></dl>

</div>
</div>
<a class="anchor" id="ga41a77d679390a374002e43a7e5b95f21"></a><!-- doxytag: member="avr_flash.c::avrf_usb_write" ref="ga41a77d679390a374002e43a7e5b95f21" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_usb_write </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction transfer the usb data (programed in scsi_write_10) directly to the memory data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD </dd></dl>

</div>
</div>
<a class="anchor" id="gaf950b7a4776b0e3215c35648fab8970d"></a><!-- doxytag: member="avr_flash.c::avrf_wr_protect" ref="gaf950b7a4776b0e3215c35648fab8970d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool avrf_wr_protect </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the write protected status of the memory. </p>
<p>Only used by memory removal with a HARDWARE SPECIFIC write protected detection !!! The customer must unplug the memory to change this write protected status, which cannot be for a DF.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE -&gt; the memory is not write-protected (always) / </dd></dl>

</div>
</div>
<a class="anchor" id="gae930b7ef893039dc7d223c465503f9eb"></a><!-- doxytag: member="avr_flash.c::avrf_write_10" ref="gae930b7ef893039dc7d223c465503f9eb" args="(U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> avrf_write_10 </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction initialise the memory for a write operation. </p>
<p>DATA FLOW is: USB =&gt; DF</p>
<p>(sector = 512B) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Sector address to start write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL </dd></dl>

</div>
</div>
<a class="anchor" id="ga194c6ce2ff9866b05187d8390d0f941a"></a><!-- doxytag: member="avr_flash.c::avrf_write_close" ref="ga194c6ce2ff9866b05187d8390d0f941a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avrf_write_close </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function fills the end of the logical sector (512B) and launch page programming. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<p>/ </p>

</div>
</div>
<a class="anchor" id="gaa02eeb6bbe862a09f6cdc9d1f1e7e626"></a><!-- doxytag: member="avr_flash.c::avrf_write_open" ref="gaa02eeb6bbe862a09f6cdc9d1f1e7e626" args="(Uint32 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_write_open </td>
          <td>(</td>
          <td class="paramtype">Uint32&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function opens a DF memory in write mode at a given sector address. </p>
<p>NOTE: If page buffer &gt; 512 bytes, page content is first loaded in buffer to be partially updated by write_byte or write64 functions.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Sector address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The open succeeded -&gt; OK / </dd></dl>

</div>
</div>
<a class="anchor" id="gafde2632a16c95692a907eada19dfaaef"></a><!-- doxytag: member="avr_flash.c::avrf_write_sector" ref="gafde2632a16c95692a907eada19dfaaef" args="(Uint16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bit avrf_write_sector </td>
          <td>(</td>
          <td class="paramtype">Uint16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is optimized and writes nb-sector * 512 Bytes from USB controller to DataFlash memory. </p>
<p>Funtions to link USB DEVICE flow with data flash.</p>
<p>DATA FLOW is: USB =&gt; DF</p>
<p>NOTE:</p>
<ul>
<li>First call must be preceded by a call to the df_write_open() function,</li>
<li>As 512 is always a sub-multiple of page size, there is no need to check page end for each Bytes,</li>
<li>The USB EPOUT must have been previously selected,</li>
<li>Interrupts are disabled during transfer to avoid <a class="el" href="a00086.html" title="A timer.">timer</a> interrupt,</li>
<li>nb_sector always &gt;= 1, cannot be zero.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>code:?? bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>number of contiguous sectors to write [IN]</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bit The write succeeded -&gt; OK / </dd></dl>

</div>
</div>
<a class="anchor" id="ga76c903dae1ac07d6ef569b5c44e1644b"></a><!-- doxytag: member="ctrl_access.c::get_cur_lun" ref="ga76c903dae1ac07d6ef569b5c44e1644b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 get_cur_lun </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return the current logical unit. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>U8 number of logical unit in the system </dd></dl>

<p>Referenced by <a class="el" href="a00725_source.html#l00150">usb_mass_storage_cbw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77a287c5aa53679242c3827b11a71252"></a><!-- doxytag: member="ctrl_access.c::get_nb_lun" ref="ga77a287c5aa53679242c3827b11a71252" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 get_nb_lun </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return the number of logical unit. </p>
<p>**** Listing of commun interface ****************************************</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>U8 number of logical unit in the system </dd></dl>

<p>Referenced by <a class="el" href="a00731_source.html#l00089">usb_user_read_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gace55e62f4e2b09da845c260ee52c69ab"></a><!-- doxytag: member="ctrl_access.c::mem_read_capacity" ref="gace55e62f4e2b09da845c260ee52c69ab" args="(U8 lun, U32 _MEM_TYPE_SLOW_ *u32_nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> mem_read_capacity </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 _MEM_TYPE_SLOW_ *&nbsp;</td>
          <td class="paramname"> <em>u32_nb_sector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return the capacity of the memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u32_nb_sector</em>&nbsp;</td><td>The sector to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>*u16_nb_sector number of sector (sector = 512B) </dd>
<dd>
Ctrl_status It is ready -&gt; CTRL_GOOD Memory unplug -&gt; CTRL_NO_PRESENT </dd></dl>

</div>
</div>
<a class="anchor" id="gab56313733936ea087a9eb2285a913554"></a><!-- doxytag: member="ctrl_access.c::mem_removal" ref="gab56313733936ea087a9eb2285a913554" args="(U8 lun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool mem_removal </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>lun</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction inform about the memory type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE -&gt; The memory is removal </dd></dl>

</div>
</div>
<a class="anchor" id="ga51555be425eeacfd88e603b9cba97049"></a><!-- doxytag: member="ctrl_access.c::mem_test_unit_ready" ref="ga51555be425eeacfd88e603b9cba97049" args="(U8 lun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> mem_test_unit_ready </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>lun</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction test the state of memory, and start the initialisation of the memory. </p>
<p>MORE (see SPC-3 §5.2.4) : The TEST UNIT READY command allows an application client to poll a logical unit until it is ready without the need to allocate space for returned data. The TEST UNIT READY command may be used to check the media status of logical units with removable media.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD Memory unplug -&gt; CTRL_NO_PRESENT Not initialize -&gt; CTRL_BUSY </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4b64acad5f46d01e082d7a7301078df"></a><!-- doxytag: member="ctrl_access.c::mem_wr_protect" ref="gaf4b64acad5f46d01e082d7a7301078df" args="(U8 lun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool mem_wr_protect </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>lun</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction return is the write protected mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<p>Only used by memory removal with a HARDWARE SPECIFIC write protected detection !!! The customer must be unplug the card for change this write protected mode.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE -&gt; the memory is protected </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bc5f6636e0c33423bd45149c8b52aa5"></a><!-- doxytag: member="ctrl_access.c::memory_2_usb" ref="ga1bc5f6636e0c33423bd45149c8b52aa5" args="(U8 lun, U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> memory_2_usb </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction returns a pointer to the LUN name. </p>
<p>**** Listing of READ/WRITE interface ************************************</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to code string----------- Listing of READ/WRITE interface with MODE ACCESS REGISTER ------------- This fonction tranfer a data from memory to usb </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Sector address to start read (sector = 512B) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL Memory unplug -&gt; CTRL_NO_PRESENT </dd></dl>

</div>
</div>
<a class="anchor" id="gabb2f5aeb58ca9e0dac6004b5abbff30b"></a><!-- doxytag: member="storage_task.c::PROCESS_THREAD" ref="gabb2f5aeb58ca9e0dac6004b5abbff30b" args="(storage_process, ev, data_proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCESS_THREAD </td>
          <td>(</td>
          <td class="paramtype">storage_process&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_proc&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Mass Storage Class Process. </p>
<p>This is the link between USB and the "good stuff". In this routine data is received and processed by USB Storage Class </p>

<p>Definition at line <a class="el" href="a00725_source.html#l00108">108</a> of file <a class="el" href="a00725_source.html">storage_task.c</a>.</p>

<p>References <a class="el" href="a00437_source.html#l00103">CLOCK_SECOND</a>, <a class="el" href="a01623.html#gada74975ee3bc980472df748b373d8636">etimer_expired()</a>, <a class="el" href="a01623.html#gadb6c83643bbca82b614c50b27c586302">etimer_set()</a>, <a class="el" href="a00734_source.html#l00078">Is_device_enumerated</a>, <a class="el" href="a00730_source.html#l00554">Is_usb_receive_out</a>, <a class="el" href="a00456_source.html#l00121">PROCESS_BEGIN</a>, <a class="el" href="a00456_source.html#l00132">PROCESS_END</a>, <a class="el" href="a00456_source.html#l00158">PROCESS_WAIT_EVENT_UNTIL</a>, <a class="el" href="a00725_source.html#l00150">usb_mass_storage_cbw()</a>, <a class="el" href="a00725_source.html#l00235">usb_mass_storage_csw()</a>, and <a class="el" href="a00730_source.html#l00460">Usb_select_endpoint</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ab123cdf7ce0be905307fad2e714557"></a><!-- doxytag: member="scsi_decoder.c::sbc_inquiry" ref="ga5ab123cdf7ce0be905307fad2e714557" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_inquiry </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI INQUIRY command (0x12). </p>
<p>The SCSI Inquiry field contains information regarding parameters of the target. For example:</p>
<ul>
<li>vendor identification</li>
<li>product identification</li>
<li>peripheral qualifier</li>
<li>peripheral device type</li>
<li>etc</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

</div>
</div>
<a class="anchor" id="gace91bd174f189c655249a901e4ce138c"></a><!-- doxytag: member="scsi_decoder.c::sbc_mode_sense" ref="gace91bd174f189c655249a901e4ce138c" args="(Bool b_sense_10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_mode_sense </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_sense_10</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI MODE SENSE command (0x1A for sense 6 and 0x5A for sense 10). </p>
<p>The SCSI mode sense function returns parameters to an application client. It is a complementary command to the SCSI MODE SELECT command.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b_sense_10</em>&nbsp;</td><td>( TRUE = sense 10, TRUE = sense 6)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

</div>
</div>
<a class="anchor" id="ga3afa976ae770c2ef5053d7b2c1b61dde"></a><!-- doxytag: member="scsi_decoder.c::sbc_prevent_allow_medium_removal" ref="ga3afa976ae770c2ef5053d7b2c1b61dde" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_prevent_allow_medium_removal </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI PREVENT ALLOW MEDIUM REMOVAL command (0x1E). </p>
<p>The SCSI prevent allow medium removal command requests that the target enable or disable the removal of the medium in the logical unit.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

</div>
</div>
<a class="anchor" id="gae6a977561cdadab81fcb0a1ddf54e599"></a><!-- doxytag: member="scsi_decoder.c::sbc_request_sense" ref="gae6a977561cdadab81fcb0a1ddf54e599" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool sbc_request_sense </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function manages the SCSI REQUEST SENSE command (0x03). </p>
<p>The SCSI Sense contains the status of the last command This status is composed of 3 Bytes :</p>
<ul>
<li>sense key (g_scsi_sense.key)</li>
<li>additional sense code (g_scsi_sense.asc)</li>
<li>additional sense code qualifier (g_scsi_sense.ascq)</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function code length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

</div>
</div>
<a class="anchor" id="gaffa6469099cc7713cfbfd73f6c5dd022"></a><!-- doxytag: member="scsi_decoder.c::scsi_decode_command" ref="gaffa6469099cc7713cfbfd73f6c5dd022" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool scsi_decode_command </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SCSI decoder function. </p>
<p>This function read the SCSI command and launches the appropriate function</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:.. bytes (function FLASH length)</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE: result KO, TRUE: result OK </dd></dl>

<p>Referenced by <a class="el" href="a00725_source.html#l00150">usb_mass_storage_cbw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga009fb70f78b2582820da7d32ecbcb44f"></a><!-- doxytag: member="ctrl_access.c::usb_2_memory" ref="ga009fb70f78b2582820da7d32ecbcb44f" args="(U8 lun, U32 addr, U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01649.html#ga910a0fdf1e7a70b08981dce14e86e291">Ctrl_status</a> usb_2_memory </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>lun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This fonction trabsfer a data from usb to memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lun</em>&nbsp;</td><td>Logical unit number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Sector address to start write (sector = 512B) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>Number of sectors to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Ctrl_status It is ready -&gt; CTRL_GOOD A error occur -&gt; CTRL_FAIL Memory unplug -&gt; CTRL_NO_PRESENT </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ad8d2f18d5af0ed75b541ab3ca9a7ff"></a><!-- doxytag: member="storage_task.c::usb_mass_storage_cbw" ref="ga8ad8d2f18d5af0ed75b541ab3ca9a7ff" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_mass_storage_cbw </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Command Block Wrapper (CBW) management. </p>
<p>This function decodes the CBW command and stores the SCSI command</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Code:?? bytes (function code length) </dd></dl>

<p><p>check if dCBWSignature is correct</p>
<p>'U'</p>
<p>'S'</p>
<p>'B'</p>
<p>'C'</p>
<p>Store CBW Tag to be repeated in CSW</p>
<p>if (bmCBWFlags.bit7 == 1) {direction = IN}</p>
<p>dummy CBWCBLength read </p>
</p>

<p>Definition at line <a class="el" href="a00725_source.html#l00150">150</a> of file <a class="el" href="a00725_source.html">storage_task.c</a>.</p>

<p>References <a class="el" href="a01022_source.html#l00175">FALSE</a>, <a class="el" href="a01649.html#ga76c903dae1ac07d6ef569b5c44e1644b">get_cur_lun()</a>, <a class="el" href="a01649.html#gaffa6469099cc7713cfbfd73f6c5dd022">scsi_decode_command()</a>, <a class="el" href="a01022_source.html#l00170">TRUE</a>, <a class="el" href="a00730_source.html#l00538">Usb_ack_receive_out</a>, <a class="el" href="a00730_source.html#l00471">Usb_enable_stall_handshake</a>, <a class="el" href="a00730_source.html#l00596">Usb_read_byte</a>, and <a class="el" href="a00730_source.html#l00460">Usb_select_endpoint</a>.</p>

<p>Referenced by <a class="el" href="a00725_source.html#l00108">PROCESS_THREAD()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed223d0bc3ba362c7f3cc8766ff614f0"></a><!-- doxytag: member="storage_task.c::usb_mass_storage_csw" ref="gaed223d0bc3ba362c7f3cc8766ff614f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_mass_storage_csw </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Command Status Wrapper (CSW) management. </p>
<p>This function sends the status in relation with the last CBW </p>

<p><p>write CSW Signature</p>
<p>'U'</p>
<p>'S'</p>
<p>'B'</p>
<p>'S' write stored CBW Tag</p>
<p>write data residue value</p>
<p>write command status</p>
<p>0 -&gt; PASS, 1 -&gt; FAIL </p>
</p>

<p>Definition at line <a class="el" href="a00725_source.html#l00235">235</a> of file <a class="el" href="a00725_source.html">storage_task.c</a>.</p>

<p>References <a class="el" href="a00730_source.html#l00483">Is_usb_endpoint_stall_requested</a>, <a class="el" href="a00730_source.html#l00552">Is_usb_receive_setup</a>, <a class="el" href="a00730_source.html#l00548">Is_usb_write_enabled</a>, <a class="el" href="a00733_source.html#l00118">usb_process_request()</a>, <a class="el" href="a00730_source.html#l00460">Usb_select_endpoint</a>, <a class="el" href="a00730_source.html#l00558">Usb_send_in</a>, and <a class="el" href="a00730_source.html#l00598">Usb_write_byte</a>.</p>

<p>Referenced by <a class="el" href="a00725_source.html#l00108">PROCESS_THREAD()</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Apr 11 14:23:54 2011 for Contiki 2.5 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
